"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioRecorder = void 0;
const getBufferHeader_1 = __importDefault(require("./getBufferHeader"));
const codecsList = {
    webm: ["opus", "vorbis"],
    ogg: ["opus", "vorbis"], // This may not work on mobile
};
class AudioRecorder {
    constructor(options, latency) {
        var _a;
        options !== null && options !== void 0 ? options : (options = {});
        this.options = options;
        if (!latency)
            latency = 1000;
        this.latency = latency;
        this.debug = (_a = options.debug) !== null && _a !== void 0 ? _a : false;
        if (options.element &&
            options.element.srcObject instanceof MediaStream) {
            this.mediaStream = options.element.srcObject;
        }
        this.recordingReady = false;
        this.mediaGranted = false;
        this.recording = false;
        this.bufferHeader = null;
        this.afterStop = false;
        this.getSupportedMimeType();
    }
    getSupportedMimeType() {
        var _a;
        if (!this.options.recorder)
            this.options.recorder = {};
        if (this.options.recorder.mimeType &&
            !MediaRecorder.isTypeSupported(this.options.recorder.mimeType)) {
            console.log("MediaRecorder doesn't supports mimetype " +
                this.options.recorder.mimeType);
            this.options.recorder.mimeType = undefined;
        }
        if (!((_a = this.options.recorder) === null || _a === void 0 ? void 0 : _a.mimeType)) {
            let supportedMimeType = undefined;
            for (let format of Object.keys(codecsList)) {
                let codecs = codecsList[format];
                let mimeType = "audio/" + format;
                for (let i = 0; i < codecs.length; i++) {
                    let temp = mimeType + ";codecs=" + codecs[i];
                    if (MediaRecorder.isTypeSupported(temp) &&
                        MediaSource.isTypeSupported(temp)) {
                        supportedMimeType = temp;
                        break;
                    }
                }
                if (!supportedMimeType &&
                    MediaRecorder.isTypeSupported(mimeType) &&
                    MediaSource.isTypeSupported(mimeType))
                    supportedMimeType = mimeType;
                if (!supportedMimeType)
                    break;
            }
            this.options.recorder.mimeType = supportedMimeType;
            if (this.debug)
                console.log("mimeType: " + supportedMimeType);
        }
    }
    onMediaGranted(mediaStream) {
        console.log("onMediaGranted:", mediaStream);
        this.mediaGranted = true;
        this.bufferHeader = null;
        let bufferHeaderLength = 0;
        this.mediaRecorder = new MediaRecorder(mediaStream, this.options.recorder);
        if (this.debug)
            console.log("MediaRecorder obtained");
        this.mediaRecorder.onstart = () => {
            this.recording = true;
        };
        const headerLatency = 100;
        this.mediaRecorder.ondataavailable = (event) => {
            var _a, _b;
            if (!((_a = this.options.recorder) === null || _a === void 0 ? void 0 : _a.mimeType)) {
                console.log("No mimeType available");
                return;
            }
            if (!this.mediaRecorder)
                return; // avoid type warnings
            if (bufferHeaderLength) {
                const streamingTime = Number(String(Date.now()).slice(-5, -3));
                (_b = this.onBuffer) === null || _b === void 0 ? void 0 : _b.call(this, [event.data, streamingTime]);
                return;
            }
            // Return if the recording was stopped
            if (this.mediaRecorder.state !== "recording")
                return;
            if (event.data.size <= 1)
                return;
            // The audio buffer can contain some duration that causes a noise
            // So we will need to remove it on streamer side
            // Because the AudioBuffer can't be converted to ArrayBuffer with WebAudioAPI
            this.bufferHeader = event.data;
            var predefinedBuffer = (0, getBufferHeader_1.default)(this.mediaRecorder.mimeType);
            if (predefinedBuffer)
                this.bufferHeader = predefinedBuffer;
            bufferHeaderLength = this.bufferHeader.size;
            if (bufferHeaderLength > 900 || bufferHeaderLength < 100)
                console.log("%c[WARN] The buffer header length was more than 0.9KB or smaller than 0.1KB. This sometime cause decode error on streamer side. Try to avoid any heavy CPU usage when using the recorder.", "color:yellow");
            if (this.onReady)
                this.onReady({
                    mimeType: this.options.recorder.mimeType,
                    startTime: Date.now(),
                    data: this.bufferHeader,
                });
            this.recordingReady = true;
            if (this.latency === headerLatency)
                return;
            // Record with the custom latency
            console.log("stopping");
            this.mediaRecorder.stop();
            setTimeout(() => {
                var _a;
                (_a = this.mediaRecorder) === null || _a === void 0 ? void 0 : _a.start(this.latency);
            }, 10);
        };
        // Get first header
        this.mediaRecorder.start(headerLatency);
    }
    reAddTracks(mediaStream) {
        if (!this.mediaRecorder)
            return;
        var streams = mediaStream.getTracks();
        for (var i = 0; i < streams.length; i++)
            this.mediaRecorder.stream.addTrack(streams[i]);
        this.mediaRecorder.start(this.latency);
        this.recording = true;
    }
    startRecording() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.afterStop) {
                this.afterStop = false;
                if (!this.options.mediaStream) {
                    const stream = yield navigator.mediaDevices.getUserMedia({
                        audio: (_a = this.options.audio) !== null && _a !== void 0 ? _a : true,
                    });
                    this.reAddTracks(stream);
                }
                return;
            }
            else if (!this.mediaGranted || !this.mediaRecorder) {
                this.recordingReady = false;
                if (this.options.mediaStream) {
                    this.onMediaGranted(this.options.mediaStream);
                }
                else {
                    const stream = yield navigator.mediaDevices.getUserMedia({
                        audio: (_b = this.options.audio) !== null && _b !== void 0 ? _b : true,
                    });
                    this.onMediaGranted(stream);
                }
                return false;
            }
            if (this.mediaRecorder.state !== "recording") {
                this.mediaRecorder.start(this.latency);
                this.recording = true;
            }
            return true;
        });
    }
    stopRecording() {
        if (!this.recording || !this.mediaRecorder) {
            return;
        }
        this.recording = false;
        this.mediaRecorder.stop();
        if (!this.options.mediaStream) {
            // Turn off stream from microphone
            var streams = this.mediaRecorder.stream.getTracks();
            for (var i = 0; i < streams.length; i++) {
                streams[i].stop();
                this.mediaRecorder.stream.removeTrack(streams[i]);
            }
        }
        // this.mediaRecorder.ondataavailable = null;
        // this.mediaRecorder.onstart = null;
        this.bufferHeader = null;
        this.afterStop = true;
        if (this.onStop)
            this.onStop();
    }
}
exports.AudioRecorder = AudioRecorder;
